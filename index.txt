<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文本 ? 密码子 (5'-3') ・ 等号随机填充</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            background: linear-gradient(145deg, #e3f0f5 0%, #d4e3ed 100%);
            min-height: 100vh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .tool-container {
            max-width: 1100px;
            width: 100%;
            background: rgba(255,255,255,0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 48px;
            padding: 32px 36px;
            box-shadow: 0 30px 50px rgba(18, 52, 77, 0.25), 0 10px 20px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.6);
        }

        h1 {
            font-size: 2.2rem;
            font-weight: 600;
            margin: 0 0 8px 0;
            letter-spacing: -0.02em;
            color: #0f344b;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        h1 span {
            background: #1f5577;
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 5px 14px;
            border-radius: 60px;
            margin-left: 12px;
        }
        .subhead {
            color: #2f5575;
            margin-bottom: 30px;
            font-size: 1rem;
            border-left: 4px solid #4982aa;
            padding-left: 20px;
            background: rgba(73, 130, 170, 0.1);
            border-radius: 0 100px 100px 0;
        }

        .double-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 28px;
            margin-top: 10px;
        }
        @media (max-width: 700px) {
            .double-panel {
                grid-template-columns: 1fr;
                gap: 36px;
            }
            .tool-container { padding: 22px; }
        }

        .io-card {
            background: white;
            border-radius: 32px;
            padding: 24px 22px;
            box-shadow: 0 12px 24px -8px rgba(19, 59, 87, 0.2);
            border: 1px solid rgba(255,255,255,0.8);
            transition: all 0.15s;
            display: flex;
            flex-direction: column;
        }
        .io-card:hover {
            box-shadow: 0 18px 32px -8px #1d4f73a0;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            font-weight: 500;
        }
        .card-header .title {
            background: #eef4fa;
            padding: 6px 18px;
            border-radius: 40px;
            font-size: 1.2rem;
            color: #123f5f;
            border: 1px solid #bed9ef;
        }
        .card-header .badge {
            background: none;
            font-size: 0.9rem;
            color: #3b6f94;
        }

        .main-input {
            width: 100%;
            height: 200px;
            padding: 18px;
            font-size: 1rem;
            font-family: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
            background: #f3f9ff;
            border: 2px solid #c6ddef;
            border-radius: 22px;
            resize: vertical;
            outline: none;
            transition: 0.2s;
            color: #032436;
            line-height: 1.5;
            margin-bottom: 16px;
            box-shadow: inset 0 3px 6px rgba(0,0,0,0.02);
        }
        .main-input:focus {
            border-color: #3174a0;
            background: #ffffff;
            box-shadow: 0 0 0 4px rgba(57, 128, 177, 0.2), inset 0 2px 4px #cbdbe9;
        }

        .button-strip {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin: 12px 0 8px 0;
            align-items: center;
        }
        .btn {
            background: white;
            border: 1.5px solid #b0cde0;
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: 550;
            font-size: 0.9rem;
            color: #1b4565;
            cursor: pointer;
            transition: 0.12s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 3px 5px rgba(0,0,0,0.02);
            letter-spacing: 0.3px;
        }
        .btn:hover {
            background: #e2effb;
            border-color: #4083b0;
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -5px #2b5f88a0;
        }
        .btn.primary {
            background: #1e5380;
            border-color: #1e5380;
            color: white;
        }
        .btn.primary:hover {
            background: #26699f;
            border-color: #1d5e90;
        }

        .clipboard-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 8px;
            border-top: 1px dashed #aec9e0;
            padding-top: 14px;
            justify-content: flex-start;
        }

        .small-hint {
            font-size: 0.75rem;
            color: #3f6c91;
            background: #d7e8fa;
            padding: 4px 12px;
            border-radius: 40px;
            display: inline-block;
            margin-left: auto;
        }

        .status-line {
            font-size: 0.8rem;
            color: #22638b;
            margin-top: 6px;
            min-height: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-line span {
            background: #e1effb;
            padding: 2px 10px;
            border-radius: 30px;
        }

        .footer-note {
            margin-top: 32px;
            text-align: center;
            color: #2b5f7a;
            font-size: 0.85rem;
            background: #ebf4fc;
            padding: 12px 24px;
            border-radius: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }
        .clear-all-btn {
            background: transparent;
            border: 1.5px solid #8fb7d3;
            padding: 8px 24px;
            border-radius: 40px;
            color: #164a6b;
            font-weight: 500;
            cursor: pointer;
            transition: 0.1s;
        }
        .clear-all-btn:hover {
            background: #ffffffb8;
            border-color: #5b92bc;
        }
        .error-flash {
            animation: errorShake 0.2s 2 ease;
        }
        @keyframes errorShake {
            0% { transform: translateX(0); }
            25% { transform: translateX(6px); }
            75% { transform: translateX(-6px); }
            100% { transform: translateX(0); }
        }
    </style>
</head>
<body>
<div class="tool-container">
    <h1>
        ? 文本 ? 密码子 (5'-3')
        <span>AUCG + 随机填充</span>
    </h1>
    <div class="subhead">左侧纯文本 → Base64（等号→随机碱基） → 右侧密码子 ・ 反向按长度模3恢复等号</div>

    <div class="double-panel">
        <!-- 左侧：纯文本输入框 -->
        <div class="io-card" id="leftCard">
            <div class="card-header">
                <div class="title">? 纯文本</div>
                <div class="badge">UTF-8</div>
            </div>
            <textarea id="textInput" class="main-input" placeholder="输入任意文本..."></textarea>
            
            <div class="button-strip">
                <button class="btn primary" id="encodeBtn">? 转成密码子</button>
                <button class="btn" id="clearTextBtn">?? 清空</button>
                <span class="small-hint">字符数 <span id="textCharCount">0</span></span>
            </div>
        </div>

        <!-- 右侧：密码子输入框 -->
        <div class="io-card" id="rightCard">
            <div class="card-header">
                <div class="title">? 密码子 (5'-3')</div>
                <div class="badge">A/U/C/G</div>
            </div>
            <textarea id="codonInput" class="main-input" placeholder="例如：AAACCCUUG... 仅大写AUCG (含随机填充)"></textarea>
            
            <div class="button-strip">
                <button class="btn primary" id="decodeBtn">? 转成文字</button>
                <button class="btn" id="clearCodonBtn">?? 清空</button>
                <span class="small-hint">长度 <span id="codonCharCount">0</span></span>
            </div>

            <!-- 专属复制/粘贴按钮行 (右侧) -->
            <div class="clipboard-row">
                <button class="btn" id="copyCodonBtn" title="复制右侧密码子内容">? 复制</button>
                <button class="btn" id="pasteCodonBtn" title="粘贴到右侧密码子框">? 粘贴</button>
                <span style="flex:1; text-align:right; font-size:0.75rem; color:#3d6f94;">授权粘贴</span>
            </div>
        </div>
    </div>

    <div class="footer-note">
        <span>? 规则：Base64末尾等号用随机碱基(A/U/C/G)替代；解码时根据长度模3自动补回等号。</span>
        <button class="clear-all-btn" id="clearAllBtn">? 清空两个输入框</button>
    </div>
</div>

<script>
    (function() {
        // ---------- 映射表 (与原表完全一致) ----------
        const codonMap = {
            'A':'AAA','B':'AAC','C':'AAG','D':'AAU','E':'ACA','F':'ACC','G':'ACG','H':'ACU','I':'AGA','J':'AGC','K':'AGG','L':'AGU','M':'AUA','N':'AUC','O':'AUG','P':'AUU','Q':'CAA','R':'CAC','S':'CAG','T':'CAU','U':'CCA','V':'CCC','W':'CCG','X':'CCU','Y':'CGA','Z':'CGC',
            'a':'CGG','b':'CGU','c':'CUA','d':'CUC','e':'CUG','f':'CUU','g':'GAA','h':'GAC','i':'GAG','j':'GAU','k':'GCA','l':'GCC','m':'GCG','n':'GCU','o':'GGA','p':'GGC','q':'GGG','r':'GGU','s':'GUA','t':'GUC','u':'GUG','v':'GUU','w':'UAA','x':'UAC','y':'UAG','z':'UAU',
            '0':'UCA','1':'UCC','2':'UCG','3':'UCU','4':'UGA','5':'UGC','6':'UGG','7':'UGU','8':'UUA','9':'UUC','+':'UUG','/':'UUU'
        };

        const reverseCodonMap = {};
        for (const [base64Char, codon] of Object.entries(codonMap)) {
            reverseCodonMap[codon] = base64Char;
        }

        // 随机碱基生成器 (A,U,C,G)
        function randomBase() {
            const bases = ['A', 'U', 'C', 'G'];
            return bases[Math.floor(Math.random() * 4)];
        }

        // ---------- DOM 元素 ----------
        const textInput = document.getElementById('textInput');
        const codonInput = document.getElementById('codonInput');
        const encodeBtn = document.getElementById('encodeBtn');
        const decodeBtn = document.getElementById('decodeBtn');
        const clearTextBtn = document.getElementById('clearTextBtn');
        const clearCodonBtn = document.getElementById('clearCodonBtn');
        const copyCodonBtn = document.getElementById('copyCodonBtn');
        const pasteCodonBtn = document.getElementById('pasteCodonBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const textCharCount = document.getElementById('textCharCount');
        const codonCharCount = document.getElementById('codonCharCount');

        // ---------- 辅助函数 ----------
        function updateCounts() {
            textCharCount.textContent = textInput.value.length;
            codonCharCount.textContent = codonInput.value.length;
        }

        function shakeElement(element) {
            element.classList.add('error-flash');
            setTimeout(() => element.classList.remove('error-flash'), 500);
        }

        // ---------- 编码: 文本 -> Base64 (处理等号) -> 密码子 ----------
        function encodeTextToCodon() {
            const rawText = textInput.value;
            if (rawText === '') {
                codonInput.value = '';
                updateCounts();
                return;
            }

            try {
                // 1. 文本 -> UTF-8字节 -> Base64
                const utf8Bytes = new TextEncoder().encode(rawText);
                let binary = '';
                for (let i = 0; i < utf8Bytes.length; i++) {
                    binary += String.fromCharCode(utf8Bytes[i]);
                }
                let base64Str = btoa(binary);  // 可能包含一个或两个等号

                // 2. 记住等号数量，并移除等号 (用随机碱基代替)
                let equalSignCount = 0;
                if (base64Str.endsWith('==')) {
                    equalSignCount = 2;
                    base64Str = base64Str.slice(0, -2); // 去掉两个等号
                } else if (base64Str.endsWith('=')) {
                    equalSignCount = 1;
                    base64Str = base64Str.slice(0, -1); // 去掉一个等号
                }

                // 3. 将Base64每个字符(不含等号)转为密码子三联体
                let codonResult = '';
                for (let i = 0; i < base64Str.length; i++) {
                    const ch = base64Str[i];
                    const codon = codonMap[ch];
                    if (!codon) {
                        throw new Error(`无效Base64字符: ${ch}`);
                    }
                    codonResult += codon;
                }

                // 4. 补上随机碱基：等号数量 * 3 个随机碱基 (每个等号对应一个三联体，但这里直接加随机三联体)
                //   注意：每个等号原本对应一个字符的位置，但我们用三联体填充。为了保持解码时能通过长度反推等号数，
                //   我们直接添加 equalSignCount * 3 个随机碱基 (即 equalSignCount 个随机三联体)
                for (let e = 0; e < equalSignCount; e++) {
                    // 添加一个随机的三联体 (3个随机碱基)
                    codonResult += randomBase() + randomBase() + randomBase();
                }

                codonInput.value = codonResult;
            } catch (e) {
                console.warn('编码失败:', e);
                codonInput.value = '[编码错误]';
                shakeElement(document.getElementById('leftCard'));
            }
            updateCounts();
        }

        // ---------- 解码: 密码子 -> Base64 (根据长度模3推断等号) -> 文本 ----------
        function decodeCodonToText() {
            let rawCodon = codonInput.value;
            if (rawCodon.trim() === '') {
                textInput.value = '';
                updateCounts();
                return;
            }

            try {
                // 1. 去除空白字符，并转换为大写 (只处理大写AUCG)
                let cleaned = rawCodon.replace(/\s+/g, '').toUpperCase();
                if (!/^[AUCG]+$/.test(cleaned)) {
                    throw new Error('密码子只能包含A、U、C、G（忽略空白）');
                }
                if (cleaned.length % 3 !== 0) {
                    throw new Error('密码子长度必须是3的倍数');
                }

                // 2. 关键：计算末尾随机填充的等号数量 = 总长度模3的余数？不对，总长度已经是3倍数。
                //   实际上，原始Base64末尾等号数量可以是0,1,2。等号被替换为3*N个碱基，所以最终密码子长度 = 原始Base64字符数*3 + 等号数*3。
                //   设 base64字符数 = n (不含等号), 等号数 = p (0/1/2)。那么密码子长度 = (n+p)*3。
                //   所以 p = (密码子长度/3) - n，但n未知。但我们不需要知道n，我们只需要知道p。
                //   然而 p 只能为0,1,2，且必须满足 (总长度/3) >= p。我们可以通过反向映射恢复base64字符串直到最后遇到无法映射?
                //   更稳健的方法：先尝试将每三个字母转为base64字符，如果最后几个三联体映射失败，说明可能是填充区。
                //   但因为我们映射表全覆盖AUCG所有组合（64种），任何三联体都能映射到一个base64字符（包括原本等号对应的三联体）。
                //   等号对应的是填充用的随机三联体，它们也会映射到某个base64字符，造成多余的字符。
                //   为了正确解码，我们必须根据等号数量截断。
                
                //   根据规则：编码时我们在真实base64字符之后添加了 p*3 个随机碱基 (p个随机三联体)。
                //   因此，真正的base64字符数 = (cleaned.length / 3) - p。
                //   解码前我们不知道p。但我们可以利用 base64 字符串长度模4 的性质来推断 p。
                //   原始的 base64Str (不带等号) 长度 n 满足：n % 4 可以是 0,2,3? 实际不带等号的base64长度 mod 4 可以是0,2,3? 
                //   标准base64：原始数据长度 mod 3 决定等号数。我们编码时去掉等号，所以等号数 p = (4 - (n % 4)) % 4，但p为1或2。
                //   但这里我们不需要这么复杂，因为我们可以直接从cleaned长度推断 p 的可能性，然后尝试解码。
                //   最简单可靠的方法：尝试p=0,1,2，看哪个能解码出可读文本（没有乱码且没有异常）。但这里为了鲁棒且简单，
                //   我们采用固定规则：从密码子尾部向前尝试，如果去掉最后3个碱基后，base64字符串长度能被4整除且末尾无非base64字符，但会有歧义。
                //   为了用户友好，我们要求用户保证末尾填充是完整的（由本工具编码产生），并采用长度模4法推断p。
               
                //   改进方法：我们令总三联体数量 = cleaned.length / 3 = T。
                //   设真实base64字符数 = N, 等号数 = P (0/1/2)。那么 T = N + P。
                //   同时原始base64字符串（不带等号）长度 N 必须满足：根据标准，原始数据长度决定N，但 N 与 P 满足： (N + P) % 4 == 0? 不完全是。
                //   实际上，在标准base64中，带等号的字符串长度总是4的倍数。我们编码时去掉了等号，所以真实base64部分长度 N 满足：
                //   如果 P=0, N % 4 可以是任意；如果 P=1, 则 N % 4 == 3；如果 P=2, 则 N % 4 == 2。
                //   因此，已知总三联体数 T，且 T = N + P，以及 N % 4 与 P 的约束。我们可以枚举P=0,1,2，计算出N=T-P，检查(N % 4)是否符合该P的条件。
                //   如果只有一个P满足，那就是它；如果有多个，理论上不可能，因为条件互斥；但边界情况T很小可能多个满足？但概率极低，我们取第一个匹配的。
                //   为了安全，如果多个匹配，我们选择P最小的？但实际编码时P是确定的。我们按规则取。

                const T = cleaned.length / 3; // 总三联体个数
                let possibleP = [];
                for (let p = 0; p <= 2; p++) {
                    const N = T - p;
                    if (N < 0) continue;
                    // 检查N mod 4 是否符合p的条件
                    if (p === 0) {
                        // 无等号: N mod 4 可以是0,1,2,3? 实际上任何余数都允许
                        possibleP.push(p);
                    } else if (p === 1) {
                        // 一个等号: 要求 N % 4 === 3
                        if (N % 4 === 3) possibleP.push(p);
                    } else if (p === 2) {
                        // 两个等号: 要求 N % 4 === 2
                        if (N % 4 === 2) possibleP.push(p);
                    }
                }

                if (possibleP.length === 0) {
                    throw new Error('无法确定等号数量（密码子长度与Base64规则不匹配）');
                }
                // 如果有多个，取第一个（理论上只会有一个，但为了鲁棒，选择P最小的那个更安全，因为少截断比多截断好？但可能解码出乱码）
                // 但实际编码产生的必然符合规则，所以只有一个。这里我们取possibleP[0]。
                const estimatedP = possibleP[0]; 
                
                // 根据估计的P，计算真实base64字符数 N = T - estimatedP
                const realCodonCount = T - estimatedP; // 真实的base64字符数（每个对应一个三联体）

                // 2. 提取前 realCodonCount 个三联体，转成base64字符串
                let base64Str = '';
                for (let i = 0; i < realCodonCount; i++) {
                    const triplet = cleaned.substr(i * 3, 3);
                    const base64Char = reverseCodonMap[triplet];
                    if (!base64Char) {
                        throw new Error(`未知的密码子三联体: ${triplet}`);
                    }
                    base64Str += base64Char;
                }

                // 3. 根据estimatedP补回等号
                if (estimatedP === 1) {
                    base64Str += '=';
                } else if (estimatedP === 2) {
                    base64Str += '==';
                }

                // 4. Base64解码回文本
                const binary = atob(base64Str);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                const decodedText = new TextDecoder().decode(bytes);
                textInput.value = decodedText;
            } catch (e) {
                console.warn('解码失败:', e);
                textInput.value = '[解码失败: ' + e.message + ']';
                shakeElement(document.getElementById('rightCard'));
            }
            updateCounts();
        }

        // 清空左侧文本
        function clearTextOnly() {
            textInput.value = '';
            updateCounts();
        }

        // 清空右侧密码子
        function clearCodonOnly() {
            codonInput.value = '';
            updateCounts();
        }

        // 清空全部
        function clearAll() {
            textInput.value = '';
            codonInput.value = '';
            updateCounts();
        }

        // 复制右侧密码子内容
        async function copyCodon() {
            const content = codonInput.value;
            if (!content) {
                alert('没有可复制的内容');
                return;
            }
            try {
                await navigator.clipboard.writeText(content);
                copyCodonBtn.style.background = '#c7e0b0';
                setTimeout(() => copyCodonBtn.style.background = '', 200);
            } catch (err) {
                alert('复制失败: ' + err.message);
            }
        }

        // 粘贴到右侧密码子框
        async function pasteToCodon() {
            try {
                const clipboardText = await navigator.clipboard.readText();
                codonInput.value = clipboardText;
                updateCounts();
            } catch (err) {
                alert('无法粘贴，请确保授予剪贴板权限或手动输入。\n' + err.message);
            }
        }

        // ---------- 事件绑定 ----------
        encodeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            encodeTextToCodon();
        });

        decodeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            decodeCodonToText();
        });

        clearTextBtn.addEventListener('click', (e) => {
            e.preventDefault();
            clearTextOnly();
        });

        clearCodonBtn.addEventListener('click', (e) => {
            e.preventDefault();
            clearCodonOnly();
        });

        copyCodonBtn.addEventListener('click', (e) => {
            e.preventDefault();
            copyCodon();
        });

        pasteCodonBtn.addEventListener('click', (e) => {
            e.preventDefault();
            pasteToCodon();
        });

        clearAllBtn.addEventListener('click', (e) => {
            e.preventDefault();
            clearAll();
        });

        // 实时计数
        textInput.addEventListener('input', updateCounts);
        codonInput.addEventListener('input', updateCounts);

        // 键盘快捷: Ctrl+Enter 触发各自转换
        textInput.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                encodeTextToCodon();
            }
        });
        codonInput.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                decodeCodonToText();
            }
        });

        // 初始计数更新
        updateCounts();
    })();
</script>
</body>
</html>
